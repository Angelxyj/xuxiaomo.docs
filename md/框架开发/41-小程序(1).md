# 微信小程序

# 一、概述

## 1、小程序是什么？

小程序，最早是特指微信小程序，英文名MiniProgram，是一种**不需要下载安装即可使用**的应用。

官方文档：https://developers.weixin.qq.com/miniprogram/dev/framework/

- 无需安装卸载
- 即用即开
- 对于h5 开发人员门槛低 ，使用html,css.js 

小程序码：

![image-20211015092233419](https://i.loli.net/2021/10/15/Bf6mPs4ijRSQo8D.png)







## 2、与网页程序h5开发的区别？

小程序的主要开发语言是 JavaScript ，对于前端开发者而言，上手容易。

- 小程序
  - 依赖于微信或其他APP上（宿主）的一个应用形式，无法脱离其所在的APP

  - 在特定的环境中去开发，所用的组件、UI都是确定好了的，也不用去考虑兼容问题
  - 在速度上，小程序基于APP端去实现，在使用时就感到很流畅

- 普通网页
  - 网页开发用在移动端或者PC端的网页开发技术
  - 开发时会有开发工具的选择、框架的选择、UI的选择等问题，还要兼顾到浏览器是否兼容的问题
  - 网页在不同的浏览器或设备中解析加载会比较慢一些
  - 网页运行在浏览器中，当然有一些App内嵌了浏览器也是可以运行的
  - 网页是需要通过网址来进行访问的



## 3、与传统App开发的区别？

- 小程序
  - 依赖于微信或其他APP上的一个应用形式，无法脱离其所在的APP
  - 无需要安装，开发技术要求较低，无需考虑应用兼容适配问题

- 传统App
  - 独立运行，不需要依赖于谁
  - 需要用户安装，开发技术要求较高且开发时还需要解决设备兼容适配问题



## 4、小程序框架结构

整个小程序框架系统分为两部分： 视图层 和 逻辑层     

- 逻辑层    js
- 数据驱动视图    只需要在逻辑层更改数据，视图层内容就会相应更新。

![](https://storage.lynnn.cn/assets/markdown/91147/pictures/2020/11/ceae6b9c066bc1d76b74b48f6a0908240f3622fe.png?sign=275325cfca1f84683602463ab2d50b98&t=5face7d2)



# 二、帐号申请与登录设置

## 1、帐号申请

官网: https://mp.weixin.qq.com/

微信小程序允许个人开发者申请账号，申请成功后才能进行下一步的学习和开发。

打开上述地址，在首页点击右上角的“立即注册”：

![](https://storage.lynnn.cn/assets/markdown/91147/pictures/2020/11/49cb632a8092bef8215b7eea8332d2026ac669ae.png?sign=cb7d9a1656f3f0115427f58867274e46&t=5face8d8)

然后注册类型选择`小程序`：

![](https://storage.lynnn.cn/assets/markdown/91147/pictures/2020/11/15fd9fa9a7f634e20db7e0469f33fa70cf721e38.png?sign=60f703428762e4ac5712269cc2d03442&t=5face8fa)

随后按照页面提示进行注册信息的填写以完成注册。



## 2、登录及配置获取

申请成功后，回到网站首页，使用注册的邮箱账号和密码（或微信扫码）进入到微信小程序官方控制平台中。

![](https://storage.lynnn.cn/assets/markdown/91147/pictures/2020/11/6f48e543227f4e9bd9051624fc87b017e2535f3f.png?sign=b099a9a6cdfc8cb46f6793c2498c7376&t=5facea22)

进入微信小程序官方控制平台后，主要为了得到开发所要用到的`appid`和`secret`这两项值。这两项值后续需要用到：

![](https://storage.lynnn.cn/assets/markdown/91147/pictures/2020/11/7855b4f5c3983b096dfd6cc4cba261285308a6e5.png?sign=540c12a29a7c37e0afb970d36b8b79b7&t=5faceeed)

需要注意：AppSecret不会明文存储并显示在页面上，需要点击`生成`按钮在显示弹窗后自行保存并记录，一旦离开当前页面（或刷新）就无法查看已经生成的AppSecret，只能对原先的进行重置。



# 三、微信开发者工具

## 1、工具的下载与安装

工具集成了公众号网页调试和小程序调试两种开发模式，开发者可以编译小程序在电脑上看到模拟器编译效果，此处根据电脑类型自行下载如下：

![](https://storage.lynnn.cn/assets/markdown/91147/pictures/2020/11/a5a22d87209b18420da1966659f5fbf3f2299577.png?sign=fd688f7247a0f9284b6d567deb9b14c1&t=5facf4e0)



## 2、helloworld项目

在桌面上双击运行`微信开发者工具`，参考以下图示进行项目创建：

![](https://storage.lynnn.cn/assets/markdown/91147/pictures/2020/11/8293dde4d26eaa6f05101cd87c29fa0765c0f5fa.png?sign=ff380c23999b57de816051334d24fb3b&t=5facff01)

创建好项目后显示效果如下：

![](https://storage.lynnn.cn/assets/markdown/91147/pictures/2020/11/95066005c96546ca74f56ff4dbdf8606b89ba06a.png?sign=c8efedddbdc170ca85e2087421906300&t=5facffea)



# 四、小程序目录结构及配置

## 1、目录结构

小程序包含一个描述整体程序（全局）的app和多个描述各自（局部）页面的page。

一个小程序**主体部分**由三个文件组成，必须放在项目的**根目录**，如下：

![](https://storage.lynnn.cn/assets/markdown/91147/pictures/2020/11/2135ba9a9f226c567fddce8fbe5c10a4543049be.png?sign=959ad7166e1c783606f1a33116ac39c1&t=5fad0559)

| **文件**     | **必填** | **作用**                  |
| ------------ | -------- | ------------------------- |
| **app.js**   | 是       | 小程序逻辑-小程序入口文件 |
| **app.json** | 是       | 小程序公共配置文件        |
| **app.wxss** | 否       | 小程序公共样式表          |

一个小程序page页面由四个文件组成，分别是：

| **文件类型** | **必填** | **作用**   |
| ------------ | -------- | ---------- |
| **js**       | 是       | 页面逻辑   |
| **wxml**     | 是       | 页面结构   |
| **wxss**     | 否       | 页面样式表 |
| **json**     | 否       | 页面配置   |





## 2、全局配置文件app.json

参考网址：https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html

app.json文件用来对微信小程序进行**全局**配置的，设置小程序页面数量、窗口表现、设置底部或顶部菜单、网络请求超时时间等。

app.json由于是`json文件`，所以其中不能添加任何注释，key和value字符串必须用**双引号**引起来，数组或对象最后**一定不能**有逗号。

常用的全局配置：  如何和页面的.json配置冲突，以页面为准

- **pages：注册小程序的页面路径列表**

> 数组的第一项代表小程序的初始页面（首页）。小程序中新增/减少页面，都需要对 pages 数组进行修改。

- **window：全局的默认窗口表现**

> 用于设置小程序的状态栏、导航条、标题、窗口背景色

- **tabBar：小程序底部或顶部菜单定义（换句话说，小程序的菜单是通过json配置来实现的）**

- networkTimeout：小程序网络请求超时时间设置

- usingComponents：自定义组件配置

![image-20211015095124049](https://i.loli.net/2021/10/15/isTAIxWZSV1uDmL.png)



## 3、全局样式文件app.wxss

定义在 app.wxss 中的样式为全局样式，作用于每一个页面。在 page 的 wxss 文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖 app.wxss 中相同的选择器。

如何和页面的样式文件冲突，以页面的配置文件为准

```css
/**app.wxss**/
/* app.wxss 全局css样式*/
/* 引入公共css */
/* @import '/static/css/common.wxss'; */
page{
  width: 750rpx;
  font-size: 24rpx;
  background:deeppink
}
```

## 4、小程序生命周期

每个小程序都需要在 `app.js` 中调用 `App` 方法注册小程序实例，绑定生命周期回调函数、错误监听和页面不存在监听函数等。

```js
// app.js
// 注册整个小程序实例对象 
// 必须调用且只能调用一次
App({
  // 整个小程序得生命周期函数
  onLaunch() {
     console.log('监听小程序初始化')
  },
  onShow(){
    console.log('监听小程序启动或切前台。')
  },
  onHide(){
    console.log('监听小程序切后台。')
  },
  globalData: {
    nameArr: ['张文静','岳小慧','宋江燕']
  }
})

```

## 5、全局数据 globalData

整个小程序只有一个 App 实例，是全部页面共享的。开发者可以通过 `getApp` 方法获取到全局唯一的 App 实例，获取App上的数据或调用开发者注册在 `App` 上的函数。

在app.js 文件中，定义globalData 属性，该属性中存放的数据在每个页面都可以获取和修改。

```js
// 在app.js 中定义全局数据
globalData: {
    nameArr: ['张文静','岳小慧','宋江燕']
  }

// 在 index.js 中获取
const app = getApp(); //获取App的实例
onLoad: function (options) {
   console.log(app) //获取 App 实例，并获取全局变量数据 globalData
 },
handleFn(){
    app.globalData.nameArr.push('逯鑫') //可以在事件中修改 globalData全局数据
}
```



# 五、WXML语法

WXML：页面的视图结构文件。简单来说，其是基于html的基础之上，小程序框架自己设计的一套标记语言。使用这套标记语言，结合JS逻辑部分、样式部分（WXSS），可以允许开发者构建出页面的效果。

**注意点：该语言标签严格要求，标签有开始，必须也有结束。**

## 1、WXML数据绑定

a. 页面中的数据都是来自于页面的逻辑文件（js文件）的data属性

![](https://storage.lynnn.cn/assets/markdown/91147/pictures/2021/02/954c2aa03ece2e18a3c6991d881767cdee897325.png?sign=0b8edfc5e8439af5c0f2b01f6a65d1bb&t=6018d3e9)

例如，我们也在`page/index/index.js`文件中新增一个数据“msg”，其值是“HTML5”。则如下：

![](https://storage.lynnn.cn/assets/markdown/91147/pictures/2021/02/01d7bef917b9c7bc1be4eb58a5ee397a18a690c6.png?sign=bb079ddaebc734133ac9aebbceb8271b&t=6018d47d)

b. 数据可以在页面结构文件（wxml文件）中展示，例如将刚才index页面的msg数据在index.wxml中展示输出（类似于vue的插值表达式）

~~~wxml
<text class="user-motto">{{msg}}</text>
~~~

c. 使用 **setData** 方法来对数据进行修改。在使用时注意this关键词指向的问题，因为这个方法是对象实例里的方法。例如，假设需要msg数据在页面加载完成后5秒钟将值修改为“H5”，则代码如下：

> 针对数据的修改一般写在页面的生命周期函数中。

语法：

~~~js
this.setData({
    msg: "H5"
});
~~~

![](https://storage.lynnn.cn/assets/markdown/91147/pictures/2021/02/8c09b56296bdf915357d38b672612be31b6258b6.png?sign=98b31e38a83fabebe85eaa4930b3a24e&t=6018d6a6)



## 2、WXML循环

**语法：**其循环的实现与vue及其相似，也是通过标签的属性来实现循环的。其属性如下：

- wx:for：该属性表示循环，其属性值是要循环的数据，**默认下标名为 index，当前项为 item**
- wx:key：使用wx:for 渲染列表，必须循环体的唯一标识符，建议可以使用数组每一项得id。
- wx:for-index：（可选）用于自定义索引变量名，默认值是`index`
- wx:for-item：（可选）用于自定义循环到的元素的变量名，默认值是item

> 关于新建page的操作提示：
>
> - 在pages目录下新建一个空的文件夹
> - 右键新建好的空的文件夹，选择菜单中的“新建page”
> - 输入页面的名称，回车即可生成page需要的四个文件及其初始化的内容
> - 根据需要决定是否要设置页面为默认页面（在app.json文件中修改新建页面的顺序）

定义一个数据源，稍后演示循环操作：

~~~js
data: {
    users: ['张三', '李四', '王五'],
        obj: [
        {
            id: 1,
            user: 'zhangsan'
        },
        {
            id: 2,
            user: 'lisi'
        },
        {
            id: 3,
            user: 'wangwu'
        }
       ]
},
~~~

参考代码：

~~~html
<!--pages/wxfor/wxfor.wxml-->
<text>pages/wxfor/wxfor.wxml</text>

<!-- 在wxml里面不用div，div可以用view标签替代 -->
<!-- 使用默认的索引和元素变量循环 -->
<view wx:for="{{users}}" wx:key="index">
    {{index}} - {{item}}
</view>

<!-- 使用自定义的索引和元素变量循环 -->
<view wx:for="{{users}}" wx:for-index="key" wx:for-item="val" wx:key="key">
    {{key}} - {{val}}
</view>

<!-- 循环数组对象的操作 -->
<view wx:for="{{obj}}" wx:key="index">
    {{item.id}} - {{item.user}}
</view>
~~~

![](https://storage.lynnn.cn/assets/markdown/91147/pictures/2021/02/dcf6f89eab6818629a5a4f338c6535489f4c1ea1.png?sign=62af67205e8a62f125d90372762b0870&t=6018dc41)



## 3、WXML判断

**语法：**与vue一样，小程序中的判断也是通过**特定的属性**来实现的。属性是：wx:if、wx:elif、wx:else。

例如，有以下的数据源：

~~~js
data: {
    age: 19
}
~~~

在视图结构代码中依据是否成年的规则去判定age是否成年了：

~~~wxml
<!--pages/wxif/wxif.wxml-->
<text>pages/wxif/wxif.wxml</text>

<view wx:if="{{age > 18}}">
    成年了，可以去蹦迪了
</view>

<view wx:elif="{{age == 18}}">
    刚好成年，不建议现在去蹦迪
</view>

<view wx:else>
    未成年，回去写作业去
</view>
~~~



## 4、模板页面引用

- WXML提供模板（template）可以在模板中定义代码片段，然后在不同的地方调用。

- 使用 name 属性，作为模板的名字。然后在<template/>内定义代码片段，使用 is 属性，声明需要的使用的模板，然后将模板所需要的 data 传入

- WXML提供两种文件引用方式：`import`（高级）和`include`


- import：有点类似以于二阶段，可以把一些常用自定义函数，写到一个文件中，在用的时候可以导入进来，然后再去调用里面的特定的函数。（按需使用）


- include：将目标文件中所有的代码（除了template标签段、wxs标签段）统统在引入的位置直接用（直接使用）

### 4.1 页面内使用模板：

当前页面内定义模板，并在当前页面使用，数据item 为当前页js 中定义的数据。

```wxml
   <!-- 定义模板 -->
   <template name="msgItem">
      <view>
         <text> {{index}}: {{msg}} </text>
         <text> Time: {{time}} </text>
      </view>
   </template>
   
    <!-- 使用模板 -->
   <template is="msgItem" data="{{...item}}"/>
   
   <!-- js -->
   Page({
    data:{
      item: {
        index: 0,
        msg: '我是模板',
        time: '2016-09-15'
      }
    },
```

# 六、WXSS样式

WXSS是一套样式语言，用于描述WXML的组件样式（有点CSS描述HTML样式的感觉）。

为了适应广大的前端开发者，WXSS具有CSS大部分特性。同时为了更适合开发微信小程序，WXSS对CSS进行了扩充以及修改。例如：

- 新增了尺寸单位
  - WXSS在底层支持新的尺寸单位rpx，可以根据屏幕宽度进行自适应，响应式尺寸单位
  - 小程序中全屏尺寸数值是 : 750rpx
  - 与px的换算关系：

| 设备         | rpx换算px (屏幕宽度/750) | px换算rpx (750/屏幕宽度) |
| :----------- | :----------------------- | :----------------------- |
| iPhone5      | 1rpx = 0.42px            | 1px = 2.34rpx            |
| iPhone6      | 1rpx = 0.5px             | 1px = 2rpx               |
| iPhone6 Plus | 1rpx = 0.552px           | 1px = 1.81rpx            |

- 提供了全局的样式和局部样式
  - 定义在app.wxss中的样式为全局样式，作用于每一个页面
  - 在page的wxss文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖app.wxss中相同的选择器

- 此外WXSS仅支持部分CSS选择器，目前支持的选择器有：

| **选择器**           | **样例**       | **样例描述**                               |
| -------------------- | -------------- | ------------------------------------------ |
| **.class**           | .intro         | 选择所有拥有class="intro"的组件            |
| **#id**              | #firstname     | 选择拥有id="firstname"的组件               |
| **element**          | view           | 选择所有view组件                           |
| **element, element** | view, checkbox | 选择所有文档的view组件和所有的checkbox组件 |
| **::after**          | view::after    | 在view组件后边插入内容                     |
| **::before**         | view::before   | 在view组件前边插入内容                     |

- **单位 rpx 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。在 iPhone6 上，屏幕宽度为375px，1rpx = 0.5px = 1像素，开发建议用 iPhone6 作为视觉稿的标准。**




# 七、tabBar

文档地址：https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#tabBar

`tabBar`就是小程序底部的导航菜单，小程序的tabBar使用比较简单，只需要在全局配置文件app.json中加上下面的配置即可，参考代码如下：

~~~json
{
    "tabBar": {
        "color": "color",
        "selectedColor": "selectedColor",
        "list": [
          {
            "pagePath": "pagePath",
            "iconPath": "iconPath",
            "selectedIconPath": "selectedIconPath",
            "text": "text"
          },
          {
            "pagePath": "pagePath",
            "iconPath": "iconPath",
            "selectedIconPath": "selectedIconPath",
            "text": "text"
          },
        ]
    }
}
~~~

参考配置实例：

~~~json
{
    "tabBar": {
        "color": "#C0C0C0",
        "selectedColor": "#000000",
        "backgroundColor": "#FFFFFF",
        "list": [
            {
                "pagePath": "pages/include/include",
                "text": "导入",
                "iconPath": "./assets/images/more.png",
                "selectedIconPath": "./assets/images/more-active.png"
            },
            {
                "pagePath": "pages/index/index",
                "text": "首页",
                "iconPath": "./assets/images/cookbook.png",
                "selectedIconPath": "./assets/images/cookbook-active.png"
            }
        ]
    }
}
~~~

注意点：

- pages数组中的默认页面（第一个元素）一定要出现在tabbar配置的list数组中，如果没有则底部菜单是不显示的；
- 如果默认页面在菜单的list数组中，但是不是list数组的一个元素，那么默认页面在第一个元素，那个菜单就会被默认选中；
- ==正常来讲，pages数组中的第一个元素（页面），即菜单list数组中的第一个栏目；==



# 八、页面生命周期

网址：https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html

由框架自己触发的一系统事件函数（钩子函数）。

小程序数据互交就是通过不同的事件函数来完成的，了解生命周期函数，对于以后的数据交互是非常重要的。

- **data属性**

页面的初始数据

- **onLoad(Object[json] query)** 

页面加载时触发。一个页面只会调用一次，可以在onLoad的参数中获取打开当前页面路径中的参数。

参数说明

| **名称**  | **类型** | **说明**                          |
| --------- | -------- | --------------------------------- |
| **query** | Object   | 打开当前页面路径中的参数 json对象 |

- **onShow()**

页面显示/切入前台时触发。一个页面可以触发N次。

- **onReady()**

页面初次渲染完成时触发。一个页面只会调用一次。

- **onHide()**

页面隐藏/切入后台时触发。一个页面可以触发多次

- **onPullDownRefresh**

监听用户下拉动作，此事件需要在app.json文件中window节点中“开启全局的下拉刷新”

“enablePullDownRefresh”:true,才能触发它  作用：下拉加载更多

- **onReachBottom**

页面上拉触底事件的处理函数，需要当前页面内容超过一屏显示  作用：上拉加载更多

- **onPageScroll**

页面滚动触发事件的处理函数，需要当前页面内容超过一屏显示  作用：滚动事件监听

- **onShareAppMessage**

用户点击右上角转发，触发此方法，在此方法中可以自定义转发的内容。 作用：自定义分享

> 分享页面的路径，必须以“/”开头。

![](https://storage.lynnn.cn/assets/markdown/91147/pictures/2021/02/c3fc1b5607ff54d1cf9fbb1bd71a5d9aee164ca3.png?sign=f68422a4f3c3ea34c804f17f65e9368c&t=6019214c)



# 九、自定义事件

## 1、事件绑定

文档地址：https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3

- 绑定事件两种写法

  - 绑定冒泡事件（不会帮我们阻止冒泡）【主要】
    - 语法：bind事件类型="方法名"			`方法名不能加括号，而且不能传参`
  - 绑定非冒泡事件（会帮我们阻止冒泡）
    - 语法：catch事件类型="方法名"		`方法名不能加括号，而且不能传参`

- 上述语法还支持在属性名中间加上“:”写法，例如：

  - bind:事件类型
  - catch:事件类型
  - 自基础版本库2.8.1以后所有的事件都支持加“:”写法

- 特别需要注意，事件类型有可能其名称与之前大不同，例如以前的点击事件类型名字是`click`，在这里点击事件其实就是手指触摸事件，官网规定触摸事件是`tap`。

- 小程序事件 有哪些？查看如下对应官网地址：

  https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html

例如，声明一个view给其绑定一个点击事件（冒泡事件）：

~~~wxml
<!--pages/eventBind/eventBind.wxml-->
<text>pages/eventBind/eventBind.wxml</text>

<!-- 给view标签绑定点击事件 -->
<view bindtap="tapHandler">
    点我一下有惊喜
</view>

<!-- 给view绑定长按事件 -->
<view bind:touchstart="start" bind:touchend="end">
    蓄力发动技能
</view>
~~~

随后需要在页面的js逻辑层文件中写对应的处理程序：tapHandler，参考代码如下

~~~js
Page({

    /**
     * 页面的初始数据
     */
    data: {
        time: 0
    },

    /**
     * tap事件的处理程序
     */
    tapHandler() {
        console.log('的确是点了，惊喜是：这节结束就下课。');
    },

    /**
     * 蓄力开始触发的事件
     */
    start() {
        // 获取当前的时间并记录
        let now = Date.now();
        this.setData({
            time: now
        })
        console.log('吟唱中.....');
    },

    /** 蓄力结束触发的事件 */
    end() {
        let diffTime = Date.now() - this.data.time;
        console.log('技能发动完毕，cd....');
        console.log('本次蓄力耗时' + diffTime + '毫秒');
    },
    // ......
});
~~~



## 2、事件对象

当组件触发事件时，**逻辑层绑定该事件的处理方法会收到一个事件对象**。通过此对象来进行小程序的自定义事件参数据传递。

事件对象在小程序中是非常有意义的，这点与vue和react不同。在小程序中，**事件对象是给事件处理程序传递参数的唯一方式**。

BaseEvent基础事件对象属性列表：

| **属性**          | **类型** | **说明**                           |
| ----------------- | -------- | ---------------------------------- |
| **type**          | String   | 事件类型                           |
| **timeStamp**     | Integer  | 页面打开到触发事件所经过的毫秒数。 |
| **target**        | Object   | 触发事件的组件的一些属性值集合     |
| **currentTarget** | Object   | 当前组件的一些属性值集合           |

注意点：target属性与currentTarget，在部分场景下是一样的，当然也存在不一样的情况。

- 如果事件依附的这个组件（标签）不存在子组件（标签）并且子有属性的时候，两者一样

- 如果事件依附的这个组件（标签）存在子组件（标签）并且子有属性的时候，则两者不一样

- 如果以后要获取事件自身的组件（标签）的数据的时候，得使用currentTarget。

- 在小程序中，如果希望在视图结构中通过事件给事件对象传递参数，则可以在标签上使用`data-数据名=“数据值”`的形式传递，例如参考代码：

  - ~~~wxml
    <!-- 传递参数100 -->
    <view bindtap="tapHandler" id="efg" data-m="100">
    	<!-- 传递参数abc -->
        <view id="abc" data-abc="abc">点我触发事件</view>
    </view>
    ~~~

  - ~~~js
    // 接收参数
    /**
      * 事件对象获取
      * 所有的事件处理程序都有一个默认的参数，这个参数就是事件对象eventObj
      */
    tapHandler(eventObj) {
        console.log(eventObj);
        // 接收事件组件/标签自己的数据
        console.log(eventObj.currentTarget.dataset.m);
        // 获取事件组件/标签子的数据
        console.log(eventObj.target.dataset.abc);
    }
    ~~~



### 4.2 页面外使用模板

- 把模板定义到外部，然后多个页面间可以共用使用定义的模板

- `import`可以在当前文件中使用目标文件定义的`template`（代码区块[标签]，可以有多个）。

**语法：**<import src="目标文件的路径"></import>

1. 在pages 目录下新建 页面temp，其代码如下：

```wxml
<!--pages/temp/temp.wxml-->
<view>
  <template name="msgItem">
      <view>
         <text> {{index}}: {{msg}} </text>
         <text> Time: {{time}} </text>
      </view>
   </template>
</view>
```

2. 在其他页面如首页中引入模板temp，并使用模板，数据item1为使用页数据（如首页）

~~~wxml
    <!-- 引入模板 -->
    <import src="../temp/temp.wxml"/>
    <!-- 使用模板 -->
    <template is="msgItem" data="{{...item1}}"/>
~~~



**注意事项：**

- import的标签使用可以存在套娃行为，也就是说可以允许出现以下情况：在C文件中importB文件，在B文件中importA文件
- import在套娃的时候需要注意，其使用template存在作用域的概念的。import导入，在使用时只能使用导入的目标文件的template，不能使用导入文件中的导入的目标文件的template。（不允许隔代使用）



### 4.3  include

`include`可以将目标文件**除了**`<template/>` `<wxs/>`外的整个代码引入，相当于是拷贝到`include`位置。

**注意：只能引入静态html代码，如果代码中涉及data中得变量，需要在引入到得当前页面data中重新定义该变量。**

**语法：**<include src="目标文件的路径"/>

1. 在pages 中新建 temp1页面

~~~wxml
<!--pages/temp1/temp1.wxml-->
<view class="box">
    <view wx:for='{{fruitArr}}' wx:key='index'>
        {{item}}
    </view>
</view>
~~~

2.在使用的页面中引入模板：

~~~wxml
<!-- 使用include 引入模板 -->
<include src="../temp1/temp1.wxml" />
~~~

小结：

- include形式不支持对目标文件的template和wxs区块的解析
- include引入即使用，import在引入后还需要再去单独使用


